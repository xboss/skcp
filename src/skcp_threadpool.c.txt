// #include "skcp_threadpool.h"

// #include <stddef.h>
// #include <stdlib.h>

// static void free_task(skcp_tp_task_t *task) {
//     if (!task) {
//         return;
//     }

//     task->fun = NULL;

//     if (task->args) {
//         SKCP_FREEIF(task->args);
//     }

//     SKCP_FREEIF(task);
// }

// static void *worker(void *args) {
//     skcp_threadpool_t *pool = (skcp_threadpool_t *)args;
//     while (!pool->shutdown) {
//         skcp_tp_task_t *task = (skcp_tp_task_t *)skcp_pop_block_queue(pool->task_q);
//         if (task && task->fun) {
//             task->fun(task->args);
//         }
//         free_task(task);
//     }
//     return NULL;
// }

// skcp_threadpool_t *skcp_tp_init(int thread_num) {
//     if (thread_num <= 0) {
//         return NULL;
//     }

//     skcp_threadpool_t *pool = (skcp_threadpool_t *)SKCP_ALLOC(sizeof(skcp_threadpool_t));
//     pool->thread_num = thread_num;
//     pool->tids = (pthread_t *)SKCP_ALLOC(sizeof(pthread_t) * thread_num);
//     if (!pool->tids) {
//         skcp_tp_free(pool);
//         return NULL;
//     }

//     pool->task_q = skcp_init_queue(-1);  // TODO: queue length
//     if (!pool->task_q) {
//         skcp_tp_free(pool);
//         return NULL;
//     }

//     for (int i = 0; i < thread_num; i++) {
//         pthread_create(&pool->tids[i], NULL, worker, (void *)pool);
//     }
//     pool->shutdown = 0;
// }

// void skcp_tp_free(skcp_threadpool_t *pool) {
//     if (!pool) {
//         return;
//     }

//     pool->shutdown = 1;

//     if (pool->task_q) {
//         skcp_free_queue(pool->task_q, free_task);
//     }

//     if (pool->tids) {
//         SKCP_FREEIF(pool->tids);
//     }

//     SKCP_FREEIF(pool);
// }

// int skcp_tp_add_task(skcp_threadpool_t *pool, skcp_tp_task_t *task) {
//     if (!task || !pool->task_q) {
//         return -1;
//     }

//     skcp_tp_task_t *task_cp = (skcp_tp_task_t *)SKCP_ALLOC(sizeof(skcp_tp_task_t));
//     task_cp->fun = task->fun;
//     task_cp->args = task->args;

//     return skcp_push_queue(pool->task_q, task_cp);
// }